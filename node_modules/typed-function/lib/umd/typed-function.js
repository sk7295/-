(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global["'typed'"] = factory());
})(this, (function () { 'use strict';

  function ok() {
    return true;
  }
  function notOk() {
    return false;
  }
  function undef() {
    return undefined;
  }
  const NOT_TYPED_FUNCTION = 'Argument is not a typed-function.';

  /**
   * @typedef {{
   *   params: Param[],
   *   fn: function,
   *   test: function,
   *   implementation: function
   * }} Signature
   *
   * @typedef {{
   *   types: Type[],
   *   hasAny: boolean,
   *   hasConversion: boolean,
   *   restParam: boolean
   * }} Param
   *
   * @typedef {{
   *   name: string,
   *   typeIndex: number,
   *   test: function,
   *   isAny: boolean,
   *   conversion?: ConversionDef,
   *   conversionIndex: number,
   * }} Type
   *
   * @typedef {{
   *   from: string,
   *   to: string,
   *   convert: function (*) : *
   * }} ConversionDef
   *
   * @typedef {{
   *   name: string,
   *   test: function(*) : boolean,
   *   isAny?: boolean
   * }} TypeDef
   */

  /**
   * @returns {() => function}
   */
  function create() {
    // data type tests

    /**
     * Returns true if the argument is a non-null "plain" object
     */
    function isPlainObject(x) {
      return typeof x === 'object' && x !== null && x.constructor === Object;
    }
    const _types = [{
      name: 'number',
      test: function (x) {
        return typeof x === 'number';
      }
    }, {
      name: 'string',
      test: function (x) {
        return typeof x === 'string';
      }
    }, {
      name: 'boolean',
      test: function (x) {
        return typeof x === 'boolean';
      }
    }, {
      name: 'Function',
      test: function (x) {
        return typeof x === 'function';
      }
    }, {
      name: 'Array',
      test: Array.isArray
    }, {
      name: 'Date',
      test: function (x) {
        return x instanceof Date;
      }
    }, {
      name: 'RegExp',
      test: function (x) {
        return x instanceof RegExp;
      }
    }, {
      name: 'Object',
      test: isPlainObject
    }, {
      name: 'null',
      test: function (x) {
        return x === null;
      }
    }, {
      name: 'undefined',
      test: function (x) {
        return x === undefined;
      }
    }];
    const anyType = {
      name: 'any',
      test: ok,
      isAny: true
    };

    // Data structures to track the types. As these are local variables in
    // create(), each typed universe will get its own copy, but the variables
    // will only be accessible through the (closures of the) functions supplied
    // as properties of the typed object, not directly.
    // These will be initialized in clear() below
    let typeMap; // primary store of all types
    let typeList; // Array of just type names, for the sake of ordering

    // And similar data structures for the type conversions:
    let nConversions = 0;
    // the actual conversions are stored on a property of the destination types

    // This is a temporary object, will be replaced with a function at the end
    let typed = {
      createCount: 0
    };

    /**
     * Takes a type name and returns the corresponding official type object
     * for that type.
     *
     * @param {string} typeName
     * @returns {TypeDef} type
     */
    function findType(typeName) {
      const type = typeMap.get(typeName);
      if (type) {
        return type;
      }
      // Remainder is error handling
      let message = 'Unknown type "' + typeName + '"';
      const name = typeName.toLowerCase();
      let otherName;
      for (otherName of typeList) {
        if (otherName.toLowerCase() === name) {
          message += '. Did you mean "' + otherName + '" ?';
          break;
        }
      }
      throw new TypeError(message);
    }

    /**
     * Adds an array `types` of type definitions to this typed instance.
     * Each type definition should be an object with properties:
     * 'name' - a string giving the name of the type; 'test' - function
     * returning a boolean that tests membership in the type; and optionally
     * 'isAny' - true only for the 'any' type.
     *
     * The second optional argument, `before`, gives the name of a type that
     * these types should be added before. The new types are added in the
     * order specified.
     * @param {TypeDef[]} types
     * @param {string | boolean} [beforeSpec='any'] before
     */
    function addTypes(types) {
      let beforeSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';
      const beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;
      const newTypes = [];
      for (let i = 0; i < types.length; ++i) {
        if (!types[i] || typeof types[i].name !== 'string' || typeof types[i].test !== 'function') {
          throw new TypeError('Object with properties {name: string, test: function} expected');
        }
        const typeName = types[i].name;
        if (typeMap.has(typeName)) {
          throw new TypeError('Duplicate type name "' + typeName + '"');
        }
        newTypes.push(typeName);
        typeMap.set(typeName, {
          name: typeName,
          test: types[i].test,
          isAny: types[i].isAny,
          index: beforeIndex + i,
          conversionsTo: [] // Newly added type can't have any conversions to it
        });
      }
      // update the typeList
      const affectedTypes = typeList.slice(beforeIndex);
      typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes);
      // Fix the indices
      for (let i = beforeIndex + newTypes.length; i < typeList.length; ++i) {
        typeMap.get(typeList[i]).index = i;
      }
    }

    /**
     * Removes all types and conversions from this typed instance.
     * May cause previously constructed typed-functions to throw
     * strange errors when they are called with types that do not
     * match any of their signatures.
     */
    function clear() {
      typeMap = new Map();
      typeList = [];
      nConversions = 0;
      addTypes([anyType], false);
    }

    // initialize the types to the default list
    clear();
    addTypes(_types);

    /**
     * Removes all conversions, leaving the types alone.
     */
    function clearConversions() {
      let typeName;
      for (typeName of typeList) {
        typeMap.get(typeName).conversionsTo = [];
      }
      nConversions = 0;
    }

    /**
     * Find the type names that match a value.
     * @param {*} value
     * @return {string[]} Array of names of types for which
     *                  the type test matches the value.
     */
    function findTypeNames(value) {
      const matches = typeList.filter(name => {
        const type = typeMap.get(name);
        return !type.isAny && type.test(value);
      });
      if (matches.length) {
        return matches;
      }
      return ['any'];
    }

    /**
     * Check if an entity is a typed function created by any instance
     * @param {any} entity
     * @returns {boolean}
     */
    function isTypedFunction(entity) {
      return entity && typeof entity === 'function' && '_typedFunctionData' in entity;
    }

    /**
     * Find a specific signature from a (composed) typed function, for example:
     *
     *   typed.findSignature(fn, ['number', 'string'])
     *   typed.findSignature(fn, 'number, string')
     *   typed.findSignature(fn, 'number,string', {exact: true})
     *
     * This function findSignature will by default return the best match to
     * the given signature, possibly employing type conversions.
     *
     * The (optional) third argument is a plain object giving options
     * controlling the signature search. Currently the only implemented
     * option is `exact`: if specified as true (default is false), only
     * exact matches will be returned (i.e. signatures for which `fn` was
     * directly defined). Note that a (possibly different) type matching
     * `any`, or one or more instances of TYPE matching `...TYPE` are
     * considered exact matches in this regard, as no conversions are used.
     *
     * This function returns a "signature" object, as does `typed.resolve()`,
     * which is a plain object with four keys: `params` (the array of parameters
     * for this signature), `fn` (the originally supplied function for this
     * signature), `test` (a generated function that determines if an argument
     * list matches this signature, and `implementation` (the function to call
     * on a matching argument list, that performs conversions if necessary and
     * then calls the originally supplied function).
     *
     * @param {Function} fn                   A typed-function
     * @param {string | string[]} signature
     *     Signature to be found, can be an array or a comma separated string.
     * @param {object} options  Controls the signature search as documented
     * @return {{ params: Param[], fn: function, test: function, implementation: function }}
     *     Returns the matching signature, or throws an error when no signature
     *     is found.
     */
    function findSignature(fn, signature, options) {
      if (!isTypedFunction(fn)) {
        throw new TypeError(NOT_TYPED_FUNCTION);
      }

      // Canonicalize input
      const exact = options && options.exact;
      const stringSignature = Array.isArray(signature) ? signature.join(',') : signature;
      const params = parseSignature(stringSignature);
      const canonicalSignature = stringifyParams(params);

      // First hope we get lucky and exactly match a signature
      if (!exact || canonicalSignature in fn.signatures) {
        // OK, we can check the internal signatures
        const match = fn._typedFunctionData.signatureMap.get(canonicalSignature);
        if (match) {
          return match;
        }
      }

      // Oh well, we did not; so we have to go back and check the parameters
      // one by one, in order to catch things like `any` and rest params.
      // Note here we can assume there is at least one parameter, because
      // the empty signature would have matched successfully above.
      const nParams = params.length;
      let remainingSignatures;
      if (exact) {
        remainingSignatures = [];
        let name;
        for (name in fn.signatures) {
          remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name));
        }
      } else {
        remainingSignatures = fn._typedFunctionData.signatures;
      }
      for (let i = 0; i < nParams; ++i) {
        const want = params[i];
        const filteredSignatures = [];
        let possibility;
        for (possibility of remainingSignatures) {
          const have = getParamAtIndex(possibility.params, i);
          if (!have || want.restParam && !have.restParam) {
            continue;
          }
          if (!have.hasAny) {
            // have to check all of the wanted types are available
            const haveTypes = paramTypeSet(have);
            if (want.types.some(wtype => !haveTypes.has(wtype.name))) {
              continue;
            }
          }
          // OK, this looks good
          filteredSignatures.push(possibility);
        }
        remainingSignatures = filteredSignatures;
        if (remainingSignatures.length === 0) break;
      }
      // Return the first remaining signature that was totally matched:
      let candidate;
      for (candidate of remainingSignatures) {
        if (candidate.params.length <= nParams) {
          return candidate;
        }
      }
      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + stringifyParams(params, ', ') + '))');
    }

    /**
     * Find the proper function to call for a specific signature from
     * a (composed) typed function, for example:
     *
     *   typed.find(fn, ['number', 'string'])
     *   typed.find(fn, 'number, string')
     *   typed.find(fn, 'number,string', {exact: true})
     *
     * This function find will by default return the best match to
     * the given signature, possibly employing type conversions (and returning
     * a function that will perform those conversions as needed). The
     * (optional) third argument is a plain object giving options contolling
     * the signature search. Currently only the option `exact` is implemented,
     * which defaults to "false". If `exact` is specified as true, then only
     * exact matches will be returned (i.e. signatures for which `fn` was
     * directly defined). Uses of `any` and `...TYPE` are considered exact if
     * no conversions are necessary to apply the corresponding function.
     *
     * @param {Function} fn                   A typed-function
     * @param {string | string[]} signature
     *     Signature to be found, can be an array or a comma separated string.
     * @param {object} options  Controls the signature match as documented
     * @return {function}
     *     Returns the function to call for the given signature, or throws an
     *     error if no match is found.
     */
    function find(fn, signature, options) {
      return findSignature(fn, signature, options).implementation;
    }

    /**
     * Convert a given value to another data type, specified by type name.
     *
     * @param {*} value
     * @param {string} typeName
     */
    function convert(value, typeName) {
      // check conversion is needed
      const type = findType(typeName);
      if (type.test(value)) {
        return value;
      }
      const conversions = type.conversionsTo;
      if (conversions.length === 0) {
        throw new Error('There are no conversions to ' + typeName + ' defined.');
      }
      for (let i = 0; i < conversions.length; i++) {
        const fromType = findType(conversions[i].